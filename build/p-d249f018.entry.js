import{r as t,h as s,g as e,a as n}from"./p-b7ed3cba.js";import{m as o,a as i,s as c,b as r,c as a,d as h,e as l,f as u,g as f,h as d,i as p,j as g,k as y,l as m,n as b,o as w,p as P}from"./p-cc12bbd3.js";import{A as O}from"./p-53c71e94.js";const j="stencil-route.inactive{display:none}";const k=class{constructor(s){t(this,s);this.group=null;this.match=null;this.componentProps={};this.exact=false;this.scrollOnNextRender=false;this.previousMatch=null}computeMatch(t){const s=this.group!=null||this.el.parentElement!=null&&this.el.parentElement.tagName.toLowerCase()==="stencil-route-switch";if(!t||s){return}this.previousMatch=this.match;return this.match=o(t.pathname,{path:this.url,exact:this.exact,strict:true})}async loadCompleted(){let t={};if(this.history&&this.history.location.hash){t={scrollToId:this.history.location.hash.substr(1)}}else if(this.scrollTopOffset){t={scrollTopOffset:this.scrollTopOffset}}if(typeof this.componentUpdated==="function"){this.componentUpdated(t)}else if(this.match&&!i(this.match,this.previousMatch)&&this.routeViewsUpdated){this.routeViewsUpdated(t)}}async componentDidUpdate(){await this.loadCompleted()}async componentDidLoad(){await this.loadCompleted()}render(){if(!this.match||!this.history){return null}const t=Object.assign({},this.componentProps,{history:this.history,match:this.match});if(this.routeRender){return this.routeRender(Object.assign({},t,{component:this.component}))}if(this.component){const e=this.component;return s(e,Object.assign({},t))}}get el(){return e(this)}static get watchers(){return{location:["computeMatch"]}}};O.injectProps(k,["location","history","historyType","routeViewsUpdated"]);k.style=j;const T=()=>((Math.random()*1e17).toString().match(/.{4}/g)||[]).join("-");const L=(t,s,e)=>o(t,{path:s,exact:e,strict:true});const S=t=>t.tagName==="STENCIL-ROUTE";const U=class{constructor(s){t(this,s);this.group=T();this.subscribers=[];this.queue=n(this,"queue")}componentWillLoad(){if(this.location!=null){this.regenerateSubscribers(this.location)}}async regenerateSubscribers(t){if(t==null){return}let s=-1;this.subscribers=Array.prototype.slice.call(this.el.children).filter(S).map(((e,n)=>{const o=L(t.pathname,e.url,e.exact);if(o&&s===-1){s=n}return{el:e,match:o}}));if(s===-1){return}if(this.activeIndex===s){this.subscribers[s].el.match=this.subscribers[s].match;return}this.activeIndex=s;const e=this.subscribers[this.activeIndex];if(this.scrollTopOffset){e.el.scrollTopOffset=this.scrollTopOffset}e.el.group=this.group;e.el.match=e.match;e.el.componentUpdated=t=>{this.queue.write((()=>{this.subscribers.forEach(((t,s)=>{t.el.componentUpdated=undefined;if(s===this.activeIndex){return t.el.style.display=""}if(this.scrollTopOffset){t.el.scrollTopOffset=this.scrollTopOffset}t.el.group=this.group;t.el.match=null;t.el.style.display="none"}))}));if(this.routeViewsUpdated){this.routeViewsUpdated(Object.assign({scrollTopOffset:this.scrollTopOffset},t))}}}render(){return s("slot",null)}get el(){return e(this)}static get watchers(){return{location:["regenerateSubscribers"]}}};O.injectProps(U,["location","routeViewsUpdated"]);const H=(t,...s)=>{if(!t){console.warn(...s)}};const A=()=>{let t;let s=[];const e=s=>{H(t==null,"A history supports only one prompt at a time");t=s;return()=>{if(t===s){t=null}}};const n=(s,e,n,o)=>{if(t!=null){const i=typeof t==="function"?t(s,e):t;if(typeof i==="string"){if(typeof n==="function"){n(i,o)}else{H(false,"A history needs a getUserConfirmation function in order to use a prompt message");o(true)}}else{o(i!==false)}}else{o(true)}};const o=t=>{let e=true;const n=(...s)=>{if(e){t(...s)}};s.push(n);return()=>{e=false;s=s.filter((t=>t!==n))}};const i=(...t)=>{s.forEach((s=>s(...t)))};return{setPrompt:e,confirmTransitionTo:n,appendListener:o,notifyListeners:i}};const E=(t,s="scrollPositions")=>{let e=new Map;const n=(s,n)=>{e.set(s,n);if(c(t,"sessionStorage")){const s=[];e.forEach(((t,e)=>{s.push([e,t])}));t.sessionStorage.setItem("scrollPositions",JSON.stringify(s))}};const o=t=>e.get(t);const i=t=>e.has(t);const r=s=>{n(s,[t.scrollX,t.scrollY])};if(c(t,"sessionStorage")){const n=t.sessionStorage.getItem(s);e=n?new Map(JSON.parse(n)):e}if("scrollRestoration"in t.history){history.scrollRestoration="manual"}return{set:n,get:o,has:i,capture:r}};const M="popstate";const v="hashchange";const x=(t,s={})=>{let e=false;const n=t.history;const o=t.location;const i=t.navigator;const c=r(t);const b=!a(i);const w=E(t);const P=s.forceRefresh!=null?s.forceRefresh:false;const O=s.getUserConfirmation!=null?s.getUserConfirmation:y;const j=s.keyLength!=null?s.keyLength:6;const k=s.basename?h(l(s.basename)):"";const T=()=>{try{return t.history.state||{}}catch(t){return{}}};const L=t=>{t=t||{};const{key:s,state:e}=t;const{pathname:n,search:i,hash:c}=o;let r=n+i+c;H(!k||d(r,k),"You are attempting to use a basename on a page whose URL path does not begin "+'with the basename. Expected path "'+r+'" to begin with "'+k+'".');if(k){r=p(r,k)}return u(r,e,s||f(j))};const S=A();const U=t=>{w.capture(Q.location.key);Object.assign(Q,t);Q.location.scrollPosition=w.get(Q.location.key);Q.length=n.length;S.notifyListeners(Q.location,Q.action)};const x=t=>{if(!m(i,t)){R(L(t.state))}};const C=()=>{R(L(T()))};const R=t=>{if(e){e=false;U()}else{const s="POP";S.confirmTransitionTo(t,s,O,(e=>{if(e){U({action:s,location:t})}else{B(t)}}))}};const B=t=>{const s=Q.location;let n=_.indexOf(s.key);let o=_.indexOf(t.key);if(n===-1){n=0}if(o===-1){o=0}const i=n-o;if(i){e=true;I(i)}};const Y=L(T());let _=[Y.key];let N=0;let V=false;const q=t=>k+g(t);const D=(t,s)=>{H(!(typeof t==="object"&&t.state!==undefined&&s!==undefined),"You should avoid providing a 2nd state argument to push when the 1st "+"argument is a location-like object that already has state; it is ignored");const e="PUSH";const i=u(t,s,f(j),Q.location);S.confirmTransitionTo(i,e,O,(t=>{if(!t){return}const s=q(i);const{key:r,state:a}=i;if(c){n.pushState({key:r,state:a},"",s);if(P){o.href=s}else{const t=_.indexOf(Q.location.key);const s=_.slice(0,t===-1?0:t+1);s.push(i.key);_=s;U({action:e,location:i})}}else{H(a===undefined,"Browser history cannot push state in browsers that do not support HTML5 history");o.href=s}}))};const F=(t,s)=>{H(!(typeof t==="object"&&t.state!==undefined&&s!==undefined),"You should avoid providing a 2nd state argument to replace when the 1st "+"argument is a location-like object that already has state; it is ignored");const e="REPLACE";const i=u(t,s,f(j),Q.location);S.confirmTransitionTo(i,e,O,(t=>{if(!t){return}const s=q(i);const{key:r,state:a}=i;if(c){n.replaceState({key:r,state:a},"",s);if(P){o.replace(s)}else{const t=_.indexOf(Q.location.key);if(t!==-1){_[t]=i.key}U({action:e,location:i})}}else{H(a===undefined,"Browser history cannot replace state in browsers that do not support HTML5 history");o.replace(s)}}))};const I=t=>{n.go(t)};const J=()=>I(-1);const W=()=>I(1);const z=s=>{N+=s;if(N===1){t.addEventListener(M,x);if(b){t.addEventListener(v,C)}}else if(N===0){t.removeEventListener(M,x);if(b){t.removeEventListener(v,C)}}};const G=(t="")=>{const s=S.setPrompt(t);if(!V){z(1);V=true}return()=>{if(V){V=false;z(-1)}return s()}};const K=t=>{const s=S.appendListener(t);z(1);return()=>{z(-1);s()}};const Q={length:n.length,action:"POP",location:Y,createHref:q,push:D,replace:F,go:I,goBack:J,goForward:W,block:G,listen:K,win:t};return Q};const C="hashchange";const R={hashbang:{encodePath:t=>t.charAt(0)==="!"?t:"!/"+w(t),decodePath:t=>t.charAt(0)==="!"?t.substr(1):t},noslash:{encodePath:w,decodePath:l},slash:{encodePath:l,decodePath:l}};const B=(t,s={})=>{let e=false;let n=null;let o=0;let i=false;const c=t.location;const r=t.history;const a=b(t.navigator);const m=s.keyLength!=null?s.keyLength:6;const{getUserConfirmation:w=y,hashType:O="slash"}=s;const j=s.basename?h(l(s.basename)):"";const{encodePath:k,decodePath:T}=R[O];const L=()=>{const t=c.href;const s=t.indexOf("#");return s===-1?"":t.substring(s+1)};const S=t=>c.hash=t;const U=t=>{const s=c.href.indexOf("#");c.replace(c.href.slice(0,s>=0?s:0)+"#"+t)};const E=()=>{let t=T(L());H(!j||d(t,j),"You are attempting to use a basename on a page whose URL path does not begin "+'with the basename. Expected path "'+t+'" to begin with "'+j+'".');if(j){t=p(t,j)}return u(t,undefined,f(m))};const M=A();const v=t=>{Object.assign(X,t);X.length=r.length;M.notifyListeners(X.location,X.action)};const x=()=>{const t=L();const s=k(t);if(t!==s){U(s)}else{const t=E();const s=X.location;if(!e&&P(s,t)){return}if(n===g(t)){return}n=null;B(t)}};const B=t=>{if(e){e=false;v()}else{const s="POP";M.confirmTransitionTo(t,s,w,(e=>{if(e){v({action:s,location:t})}else{Y(t)}}))}};const Y=t=>{const s=X.location;let n=q.lastIndexOf(g(s));let o=q.lastIndexOf(g(t));if(n===-1){n=0}if(o===-1){o=0}const i=n-o;if(i){e=true;J(i)}};const _=L();const N=k(_);if(_!==N){U(N)}const V=E();let q=[g(V)];const D=t=>"#"+k(j+g(t));const F=(t,s)=>{H(s===undefined,"Hash history cannot push state; it is ignored");const e="PUSH";const o=u(t,undefined,f(m),X.location);M.confirmTransitionTo(o,e,w,(t=>{if(!t){return}const s=g(o);const i=k(j+s);const c=L()!==i;if(c){n=s;S(i);const t=q.lastIndexOf(g(X.location));const c=q.slice(0,t===-1?0:t+1);c.push(s);q=c;v({action:e,location:o})}else{H(false,"Hash history cannot PUSH the same path; a new entry will not be added to the history stack");v()}}))};const I=(t,s)=>{H(s===undefined,"Hash history cannot replace state; it is ignored");const e="REPLACE";const o=u(t,undefined,f(m),X.location);M.confirmTransitionTo(o,e,w,(t=>{if(!t){return}const s=g(o);const i=k(j+s);const c=L()!==i;if(c){n=s;U(i)}const r=q.indexOf(g(X.location));if(r!==-1){q[r]=s}v({action:e,location:o})}))};const J=t=>{H(a,"Hash history go(n) causes a full page reload in this browser");r.go(t)};const W=()=>J(-1);const z=()=>J(1);const G=(t,s)=>{o+=s;if(o===1){t.addEventListener(C,x)}else if(o===0){t.removeEventListener(C,x)}};const K=(s="")=>{const e=M.setPrompt(s);if(!i){G(t,1);i=true}return()=>{if(i){i=false;G(t,-1)}return e()}};const Q=s=>{const e=M.appendListener(s);G(t,1);return()=>{G(t,-1);e()}};const X={length:r.length,action:"POP",location:V,createHref:D,push:F,replace:I,go:J,goBack:W,goForward:z,block:K,listen:Q,win:t};return X};const Y=(t,s)=>{const e=t.pathname.indexOf(s)==0?"/"+t.pathname.slice(s.length):t.pathname;return Object.assign({},t,{pathname:e})};const _={browser:x,hash:B};const N=class{constructor(s){t(this,s);this.root="/";this.historyType="browser";this.titleSuffix="";this.routeViewsUpdated=(t={})=>{if(this.history&&t.scrollToId&&this.historyType==="browser"){const s=this.history.win.document.getElementById(t.scrollToId);if(s){return s.scrollIntoView()}}this.scrollTo(t.scrollTopOffset||this.scrollTopOffset)};this.isServer=n(this,"isServer");this.queue=n(this,"queue")}componentWillLoad(){this.history=_[this.historyType](this.el.ownerDocument.defaultView);this.history.listen((t=>{t=Y(t,this.root);this.location=t}));this.location=Y(this.history.location,this.root)}scrollTo(t){const s=this.history;if(t==null||this.isServer||!s){return}if(s.action==="POP"&&Array.isArray(s.location.scrollPosition)){return this.queue.write((()=>{if(s&&s.location&&Array.isArray(s.location.scrollPosition)){s.win.scrollTo(s.location.scrollPosition[0],s.location.scrollPosition[1])}}))}return this.queue.write((()=>{s.win.scrollTo(0,t)}))}render(){if(!this.location||!this.history){return}const t={historyType:this.historyType,location:this.location,titleSuffix:this.titleSuffix,root:this.root,history:this.history,routeViewsUpdated:this.routeViewsUpdated};return s(O.Provider,{state:t},s("slot",null))}get el(){return e(this)}};export{k as stencil_route,U as stencil_route_switch,N as stencil_router};
//# sourceMappingURL=p-d249f018.entry.js.map