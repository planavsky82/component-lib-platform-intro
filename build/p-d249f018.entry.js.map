{"version":3,"names":["routeCss","Route","constructor","hostRef","this","group","match","componentProps","exact","scrollOnNextRender","previousMatch","computeMatch","newLocation","isGrouped","el","parentElement","tagName","toLowerCase","matchPath","pathname","path","url","strict","async","routeViewOptions","history","location","hash","scrollToId","substr","scrollTopOffset","componentUpdated","matchesAreEqual","routeViewsUpdated","loadCompleted","render","childProps","Object","assign","routeRender","component","ChildComponent","h","ActiveRouter","injectProps","getUniqueId","Math","random","toString","join","getMatch","isHTMLStencilRouteElement","elm","RouteSwitch","subscribers","componentWillLoad","regenerateSubscribers","newActiveIndex","Array","prototype","slice","call","children","filter","map","childElement","index","activeIndex","activeChild","routeViewUpdatedOptions","queue","write","forEach","child","undefined","style","display","warning","value","args","console","warn","createTransitionManager","prompt","listeners","setPrompt","nextPrompt","confirmTransitionTo","action","getUserConfirmation","callback","result","appendListener","fn","isActive","listener","push","item","notifyListeners","createScrollHistory","win","applicationScrollKey","scrollPositions","Map","set","key","storageAvailable","arrayData","sessionStorage","setItem","JSON","stringify","get","has","capture","scrollX","scrollY","scrollData","getItem","parse","scrollRestoration","PopStateEvent","HashChangeEvent","createBrowserHistory","props","forceNextPop","globalHistory","globalLocation","globalNavigator","navigator","canUseHistory","supportsHistory","needsHashChangeListener","supportsPopStateOnHashChange","scrollHistory","forceRefresh","getConfirmation","keyLength","basename","stripTrailingSlash","addLeadingSlash","getHistoryState","state","e","getDOMLocation","historyState","search","hasBasename","stripBasename","createLocation","createKey","transitionManager","setState","nextState","scrollPosition","length","handlePopState","event","isExtraneousPopstateEvent","handlePop","handleHashChange","ok","revertPop","fromLocation","toLocation","toIndex","allKeys","indexOf","fromIndex","delta","go","initialLocation","listenerCount","isBlocked","createHref","createPath","href","pushState","prevIndex","nextKeys","replace","replaceState","n","goBack","goForward","checkDOMListeners","addEventListener","removeEventListener","block","unblock","listen","unlisten","HashPathCoders","hashbang","encodePath","charAt","stripLeadingSlash","decodePath","noslash","slash","createHashHistory","ignorePath","canGoWithoutReload","supportsGoWithoutReloadUsingHash","hashType","getHashPath","hashIndex","substring","pushHashPath","replaceHashPath","encodedPath","prevLocation","locationsAreEqual","allPaths","lastIndexOf","hashChanged","nextPaths","getLocation","root","HISTORIES","browser","createHistory","Router","historyType","titleSuffix","options","document","getElementById","scrollIntoView","scrollTo","ownerDocument","defaultView","scrollToLocation","isServer","isArray","Provider"],"sources":["../../../node_modules/@stencil/router/dist/collection/components/route/route.css?tag=stencil-route","../../../node_modules/@stencil/router/dist/collection/components/route/route.js","../../../node_modules/@stencil/router/dist/collection/components/switch/switch.js","../../../node_modules/@stencil/router/dist/collection/utils/log.js","../../../node_modules/@stencil/router/dist/collection/utils/createTransitionManager.js","../../../node_modules/@stencil/router/dist/collection/utils/createScrollHistory.js","../../../node_modules/@stencil/router/dist/collection/utils/createBrowserHistory.js","../../../node_modules/@stencil/router/dist/collection/utils/createHashHistory.js","../../../node_modules/@stencil/router/dist/collection/components/router/router.js"],"sourcesContent":["stencil-route.inactive {\n  display: none;\n}\n","import { h } from '@stencil/core';\r\nimport { matchPath, matchesAreEqual } from '../../utils/match-path';\r\nimport ActiveRouter from '../../global/active-router';\r\n/**\r\n  * @name Route\r\n  * @module ionic\r\n  * @description\r\n */\r\nexport class Route {\r\n    constructor() {\r\n        this.group = null;\r\n        this.match = null;\r\n        this.componentProps = {};\r\n        this.exact = false;\r\n        this.scrollOnNextRender = false;\r\n        this.previousMatch = null;\r\n    }\r\n    // Identify if the current route is a match.\r\n    computeMatch(newLocation) {\r\n        const isGrouped = this.group != null || (this.el.parentElement != null && this.el.parentElement.tagName.toLowerCase() === 'stencil-route-switch');\r\n        if (!newLocation || isGrouped) {\r\n            return;\r\n        }\r\n        this.previousMatch = this.match;\r\n        return this.match = matchPath(newLocation.pathname, {\r\n            path: this.url,\r\n            exact: this.exact,\r\n            strict: true\r\n        });\r\n    }\r\n    async loadCompleted() {\r\n        let routeViewOptions = {};\r\n        if (this.history && this.history.location.hash) {\r\n            routeViewOptions = {\r\n                scrollToId: this.history.location.hash.substr(1)\r\n            };\r\n        }\r\n        else if (this.scrollTopOffset) {\r\n            routeViewOptions = {\r\n                scrollTopOffset: this.scrollTopOffset\r\n            };\r\n        }\r\n        // After all children have completed then tell switch\r\n        // the provided callback will get executed after this route is in view\r\n        if (typeof this.componentUpdated === 'function') {\r\n            this.componentUpdated(routeViewOptions);\r\n            // If this is an independent route and it matches then routes have updated.\r\n            // If the only change to location is a hash change then do not scroll.\r\n        }\r\n        else if (this.match && !matchesAreEqual(this.match, this.previousMatch) && this.routeViewsUpdated) {\r\n            this.routeViewsUpdated(routeViewOptions);\r\n        }\r\n    }\r\n    async componentDidUpdate() {\r\n        await this.loadCompleted();\r\n    }\r\n    async componentDidLoad() {\r\n        await this.loadCompleted();\r\n    }\r\n    render() {\r\n        // If there is no activeRouter then do not render\r\n        // Check if this route is in the matching URL (for example, a parent route)\r\n        if (!this.match || !this.history) {\r\n            return null;\r\n        }\r\n        // component props defined in route\r\n        // the history api\r\n        // current match data including params\r\n        const childProps = Object.assign({}, this.componentProps, { history: this.history, match: this.match });\r\n        // If there is a routerRender defined then use\r\n        // that and pass the component and component props with it.\r\n        if (this.routeRender) {\r\n            return this.routeRender(Object.assign({}, childProps, { component: this.component }));\r\n        }\r\n        if (this.component) {\r\n            const ChildComponent = this.component;\r\n            return (h(ChildComponent, Object.assign({}, childProps)));\r\n        }\r\n    }\r\n    static get is() { return \"stencil-route\"; }\r\n    static get originalStyleUrls() { return {\r\n        \"$\": [\"route.css\"]\r\n    }; }\r\n    static get styleUrls() { return {\r\n        \"$\": [\"route.css\"]\r\n    }; }\r\n    static get properties() { return {\r\n        \"group\": {\r\n            \"type\": \"string\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"string | null\",\r\n                \"resolved\": \"null | string\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"group\",\r\n            \"reflect\": true,\r\n            \"defaultValue\": \"null\"\r\n        },\r\n        \"componentUpdated\": {\r\n            \"type\": \"unknown\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"(options: RouteViewOptions) => void\",\r\n                \"resolved\": \"((options: RouteViewOptions) => void) | undefined\",\r\n                \"references\": {\r\n                    \"RouteViewOptions\": {\r\n                        \"location\": \"import\",\r\n                        \"path\": \"../../global/interfaces\"\r\n                    }\r\n                }\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            }\r\n        },\r\n        \"match\": {\r\n            \"type\": \"unknown\",\r\n            \"mutable\": true,\r\n            \"complexType\": {\r\n                \"original\": \"MatchResults | null\",\r\n                \"resolved\": \"MatchResults | null\",\r\n                \"references\": {\r\n                    \"MatchResults\": {\r\n                        \"location\": \"import\",\r\n                        \"path\": \"../../global/interfaces\"\r\n                    }\r\n                }\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            },\r\n            \"defaultValue\": \"null\"\r\n        },\r\n        \"url\": {\r\n            \"type\": \"string\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"string | string[]\",\r\n                \"resolved\": \"string | string[] | undefined\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"url\",\r\n            \"reflect\": false\r\n        },\r\n        \"component\": {\r\n            \"type\": \"string\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"string\",\r\n                \"resolved\": \"string | undefined\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"component\",\r\n            \"reflect\": false\r\n        },\r\n        \"componentProps\": {\r\n            \"type\": \"unknown\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"{ [key: string]: any }\",\r\n                \"resolved\": \"undefined | { [key: string]: any; }\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            },\r\n            \"defaultValue\": \"{}\"\r\n        },\r\n        \"exact\": {\r\n            \"type\": \"boolean\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"boolean\",\r\n                \"resolved\": \"boolean\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"exact\",\r\n            \"reflect\": false,\r\n            \"defaultValue\": \"false\"\r\n        },\r\n        \"routeRender\": {\r\n            \"type\": \"unknown\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"(props: RouteRenderProps) => any\",\r\n                \"resolved\": \"((props: RouteRenderProps) => any) | undefined\",\r\n                \"references\": {\r\n                    \"RouteRenderProps\": {\r\n                        \"location\": \"import\",\r\n                        \"path\": \"../../global/interfaces\"\r\n                    }\r\n                }\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            }\r\n        },\r\n        \"scrollTopOffset\": {\r\n            \"type\": \"number\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"number\",\r\n                \"resolved\": \"number | undefined\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"scroll-top-offset\",\r\n            \"reflect\": false\r\n        },\r\n        \"routeViewsUpdated\": {\r\n            \"type\": \"unknown\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"(options: RouteViewOptions) => void\",\r\n                \"resolved\": \"((options: RouteViewOptions) => void) | undefined\",\r\n                \"references\": {\r\n                    \"RouteViewOptions\": {\r\n                        \"location\": \"import\",\r\n                        \"path\": \"../../global/interfaces\"\r\n                    }\r\n                }\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            }\r\n        },\r\n        \"location\": {\r\n            \"type\": \"unknown\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"LocationSegments\",\r\n                \"resolved\": \"LocationSegments | undefined\",\r\n                \"references\": {\r\n                    \"LocationSegments\": {\r\n                        \"location\": \"import\",\r\n                        \"path\": \"../../global/interfaces\"\r\n                    }\r\n                }\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            }\r\n        },\r\n        \"history\": {\r\n            \"type\": \"unknown\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"RouterHistory\",\r\n                \"resolved\": \"RouterHistory | undefined\",\r\n                \"references\": {\r\n                    \"RouterHistory\": {\r\n                        \"location\": \"import\",\r\n                        \"path\": \"../../global/interfaces\"\r\n                    }\r\n                }\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            }\r\n        },\r\n        \"historyType\": {\r\n            \"type\": \"string\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"HistoryType\",\r\n                \"resolved\": \"\\\"browser\\\" | \\\"hash\\\" | undefined\",\r\n                \"references\": {\r\n                    \"HistoryType\": {\r\n                        \"location\": \"import\",\r\n                        \"path\": \"../../global/interfaces\"\r\n                    }\r\n                }\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"history-type\",\r\n            \"reflect\": false\r\n        }\r\n    }; }\r\n    static get elementRef() { return \"el\"; }\r\n    static get watchers() { return [{\r\n            \"propName\": \"location\",\r\n            \"methodName\": \"computeMatch\"\r\n        }]; }\r\n}\r\nActiveRouter.injectProps(Route, [\r\n    'location',\r\n    'history',\r\n    'historyType',\r\n    'routeViewsUpdated'\r\n]);\r\n","import { h } from '@stencil/core';\r\nimport ActiveRouter from '../../global/active-router';\r\nimport { matchPath } from '../../utils/match-path';\r\nconst getUniqueId = () => {\r\n    return ((Math.random() * 10e16).toString().match(/.{4}/g) || []).join('-');\r\n};\r\nconst getMatch = (pathname, url, exact) => {\r\n    return matchPath(pathname, {\r\n        path: url,\r\n        exact: exact,\r\n        strict: true\r\n    });\r\n};\r\nconst isHTMLStencilRouteElement = (elm) => {\r\n    return elm.tagName === 'STENCIL-ROUTE';\r\n};\r\nexport class RouteSwitch {\r\n    constructor() {\r\n        this.group = getUniqueId();\r\n        this.subscribers = [];\r\n    }\r\n    componentWillLoad() {\r\n        if (this.location != null) {\r\n            this.regenerateSubscribers(this.location);\r\n        }\r\n    }\r\n    async regenerateSubscribers(newLocation) {\r\n        if (newLocation == null) {\r\n            return;\r\n        }\r\n        let newActiveIndex = -1;\r\n        this.subscribers = Array.prototype.slice.call(this.el.children)\r\n            .filter(isHTMLStencilRouteElement)\r\n            .map((childElement, index) => {\r\n            const match = getMatch(newLocation.pathname, childElement.url, childElement.exact);\r\n            if (match && newActiveIndex === -1) {\r\n                newActiveIndex = index;\r\n            }\r\n            return {\r\n                el: childElement,\r\n                match: match\r\n            };\r\n        });\r\n        if (newActiveIndex === -1) {\r\n            return;\r\n        }\r\n        // Check if this actually changes which child is active\r\n        // then just pass the new match down if the active route isn't changing.\r\n        if (this.activeIndex === newActiveIndex) {\r\n            this.subscribers[newActiveIndex].el.match = this.subscribers[newActiveIndex].match;\r\n            return;\r\n        }\r\n        this.activeIndex = newActiveIndex;\r\n        // Set all props on the new active route then wait until it says that it\r\n        // is completed\r\n        const activeChild = this.subscribers[this.activeIndex];\r\n        if (this.scrollTopOffset) {\r\n            activeChild.el.scrollTopOffset = this.scrollTopOffset;\r\n        }\r\n        activeChild.el.group = this.group;\r\n        activeChild.el.match = activeChild.match;\r\n        activeChild.el.componentUpdated = (routeViewUpdatedOptions) => {\r\n            // After the new active route has completed then update visibility of routes\r\n            this.queue.write(() => {\r\n                this.subscribers.forEach((child, index) => {\r\n                    child.el.componentUpdated = undefined;\r\n                    if (index === this.activeIndex) {\r\n                        return child.el.style.display = '';\r\n                    }\r\n                    if (this.scrollTopOffset) {\r\n                        child.el.scrollTopOffset = this.scrollTopOffset;\r\n                    }\r\n                    child.el.group = this.group;\r\n                    child.el.match = null;\r\n                    child.el.style.display = 'none';\r\n                });\r\n            });\r\n            if (this.routeViewsUpdated) {\r\n                this.routeViewsUpdated(Object.assign({ scrollTopOffset: this.scrollTopOffset }, routeViewUpdatedOptions));\r\n            }\r\n        };\r\n    }\r\n    render() {\r\n        return (h(\"slot\", null));\r\n    }\r\n    static get is() { return \"stencil-route-switch\"; }\r\n    static get properties() { return {\r\n        \"group\": {\r\n            \"type\": \"string\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"string\",\r\n                \"resolved\": \"string\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"group\",\r\n            \"reflect\": true,\r\n            \"defaultValue\": \"getUniqueId()\"\r\n        },\r\n        \"scrollTopOffset\": {\r\n            \"type\": \"number\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"number\",\r\n                \"resolved\": \"number | undefined\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"scroll-top-offset\",\r\n            \"reflect\": false\r\n        },\r\n        \"location\": {\r\n            \"type\": \"unknown\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"LocationSegments\",\r\n                \"resolved\": \"LocationSegments | undefined\",\r\n                \"references\": {\r\n                    \"LocationSegments\": {\r\n                        \"location\": \"import\",\r\n                        \"path\": \"../../global/interfaces\"\r\n                    }\r\n                }\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            }\r\n        },\r\n        \"routeViewsUpdated\": {\r\n            \"type\": \"unknown\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"(options: RouteViewOptions) => void\",\r\n                \"resolved\": \"((options: RouteViewOptions) => void) | undefined\",\r\n                \"references\": {\r\n                    \"RouteViewOptions\": {\r\n                        \"location\": \"import\",\r\n                        \"path\": \"../../global/interfaces\"\r\n                    }\r\n                }\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            }\r\n        }\r\n    }; }\r\n    static get contextProps() { return [{\r\n            \"name\": \"queue\",\r\n            \"context\": \"queue\"\r\n        }]; }\r\n    static get elementRef() { return \"el\"; }\r\n    static get watchers() { return [{\r\n            \"propName\": \"location\",\r\n            \"methodName\": \"regenerateSubscribers\"\r\n        }]; }\r\n}\r\nActiveRouter.injectProps(RouteSwitch, [\r\n    'location',\r\n    'routeViewsUpdated'\r\n]);\r\n","export const warning = (value, ...args) => {\r\n    if (!value) {\r\n        console.warn(...args);\r\n    }\r\n};\r\n","// Adapted from the https://github.com/ReactTraining/history and converted to TypeScript\r\nimport { warning } from './log';\r\nconst createTransitionManager = () => {\r\n    let prompt;\r\n    let listeners = [];\r\n    const setPrompt = (nextPrompt) => {\r\n        warning(prompt == null, 'A history supports only one prompt at a time');\r\n        prompt = nextPrompt;\r\n        return () => {\r\n            if (prompt === nextPrompt) {\r\n                prompt = null;\r\n            }\r\n        };\r\n    };\r\n    const confirmTransitionTo = (location, action, getUserConfirmation, callback) => {\r\n        // TODO: If another transition starts while we're still confirming\r\n        // the previous one, we may end up in a weird state. Figure out the\r\n        // best way to handle this.\r\n        if (prompt != null) {\r\n            const result = typeof prompt === 'function' ? prompt(location, action) : prompt;\r\n            if (typeof result === 'string') {\r\n                if (typeof getUserConfirmation === 'function') {\r\n                    getUserConfirmation(result, callback);\r\n                }\r\n                else {\r\n                    warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message');\r\n                    callback(true);\r\n                }\r\n            }\r\n            else {\r\n                // Return false from a transition hook to cancel the transition.\r\n                callback(result !== false);\r\n            }\r\n        }\r\n        else {\r\n            callback(true);\r\n        }\r\n    };\r\n    const appendListener = (fn) => {\r\n        let isActive = true;\r\n        const listener = (...args) => {\r\n            if (isActive) {\r\n                fn(...args);\r\n            }\r\n        };\r\n        listeners.push(listener);\r\n        return () => {\r\n            isActive = false;\r\n            listeners = listeners.filter(item => item !== listener);\r\n        };\r\n    };\r\n    const notifyListeners = (...args) => {\r\n        listeners.forEach(listener => listener(...args));\r\n    };\r\n    return {\r\n        setPrompt,\r\n        confirmTransitionTo,\r\n        appendListener,\r\n        notifyListeners\r\n    };\r\n};\r\nexport default createTransitionManager;\r\n","import { storageAvailable } from './dom-utils';\r\nconst createScrollHistory = (win, applicationScrollKey = 'scrollPositions') => {\r\n    let scrollPositions = new Map();\r\n    const set = (key, value) => {\r\n        scrollPositions.set(key, value);\r\n        if (storageAvailable(win, 'sessionStorage')) {\r\n            const arrayData = [];\r\n            scrollPositions.forEach((value, key) => {\r\n                arrayData.push([key, value]);\r\n            });\r\n            win.sessionStorage.setItem('scrollPositions', JSON.stringify(arrayData));\r\n        }\r\n    };\r\n    const get = (key) => {\r\n        return scrollPositions.get(key);\r\n    };\r\n    const has = (key) => {\r\n        return scrollPositions.has(key);\r\n    };\r\n    const capture = (key) => {\r\n        set(key, [win.scrollX, win.scrollY]);\r\n    };\r\n    if (storageAvailable(win, 'sessionStorage')) {\r\n        const scrollData = win.sessionStorage.getItem(applicationScrollKey);\r\n        scrollPositions = scrollData ?\r\n            new Map(JSON.parse(scrollData)) :\r\n            scrollPositions;\r\n    }\r\n    if ('scrollRestoration' in win.history) {\r\n        history.scrollRestoration = 'manual';\r\n    }\r\n    return {\r\n        set,\r\n        get,\r\n        has,\r\n        capture\r\n    };\r\n};\r\nexport default createScrollHistory;\r\n","// Adapted from the https://github.com/ReactTraining/history and converted to TypeScript\r\nimport { createLocation, createKey } from './location-utils';\r\nimport { warning } from './log';\r\nimport { addLeadingSlash, stripTrailingSlash, hasBasename, stripBasename, createPath } from './path-utils';\r\nimport createTransitionManager from './createTransitionManager';\r\nimport createScrollHistory from './createScrollHistory';\r\nimport { getConfirmation, supportsHistory, supportsPopStateOnHashChange, isExtraneousPopstateEvent } from './dom-utils';\r\nconst PopStateEvent = 'popstate';\r\nconst HashChangeEvent = 'hashchange';\r\n/**\r\n * Creates a history object that uses the HTML5 history API including\r\n * pushState, replaceState, and the popstate event.\r\n */\r\nconst createBrowserHistory = (win, props = {}) => {\r\n    let forceNextPop = false;\r\n    const globalHistory = win.history;\r\n    const globalLocation = win.location;\r\n    const globalNavigator = win.navigator;\r\n    const canUseHistory = supportsHistory(win);\r\n    const needsHashChangeListener = !supportsPopStateOnHashChange(globalNavigator);\r\n    const scrollHistory = createScrollHistory(win);\r\n    const forceRefresh = (props.forceRefresh != null) ? props.forceRefresh : false;\r\n    const getUserConfirmation = (props.getUserConfirmation != null) ? props.getUserConfirmation : getConfirmation;\r\n    const keyLength = (props.keyLength != null) ? props.keyLength : 6;\r\n    const basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\r\n    const getHistoryState = () => {\r\n        try {\r\n            return win.history.state || {};\r\n        }\r\n        catch (e) {\r\n            // IE 11 sometimes throws when accessing window.history.state\r\n            // See https://github.com/ReactTraining/history/pull/289\r\n            return {};\r\n        }\r\n    };\r\n    const getDOMLocation = (historyState) => {\r\n        historyState = historyState || {};\r\n        const { key, state } = historyState;\r\n        const { pathname, search, hash } = globalLocation;\r\n        let path = pathname + search + hash;\r\n        warning((!basename || hasBasename(path, basename)), 'You are attempting to use a basename on a page whose URL path does not begin ' +\r\n            'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\r\n        if (basename) {\r\n            path = stripBasename(path, basename);\r\n        }\r\n        return createLocation(path, state, key || createKey(keyLength));\r\n    };\r\n    const transitionManager = createTransitionManager();\r\n    const setState = (nextState) => {\r\n        // Capture location for the view before changing history.\r\n        scrollHistory.capture(history.location.key);\r\n        Object.assign(history, nextState);\r\n        // Set scroll position based on its previous storage value\r\n        history.location.scrollPosition = scrollHistory.get(history.location.key);\r\n        history.length = globalHistory.length;\r\n        transitionManager.notifyListeners(history.location, history.action);\r\n    };\r\n    const handlePopState = (event) => {\r\n        // Ignore extraneous popstate events in WebKit.\r\n        if (!isExtraneousPopstateEvent(globalNavigator, event)) {\r\n            handlePop(getDOMLocation(event.state));\r\n        }\r\n    };\r\n    const handleHashChange = () => {\r\n        handlePop(getDOMLocation(getHistoryState()));\r\n    };\r\n    const handlePop = (location) => {\r\n        if (forceNextPop) {\r\n            forceNextPop = false;\r\n            setState();\r\n        }\r\n        else {\r\n            const action = 'POP';\r\n            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n                if (ok) {\r\n                    setState({ action, location });\r\n                }\r\n                else {\r\n                    revertPop(location);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    const revertPop = (fromLocation) => {\r\n        const toLocation = history.location;\r\n        // TODO: We could probably make this more reliable by\r\n        // keeping a list of keys we've seen in sessionStorage.\r\n        // Instead, we just default to 0 for keys we don't know.\r\n        let toIndex = allKeys.indexOf(toLocation.key);\r\n        let fromIndex = allKeys.indexOf(fromLocation.key);\r\n        if (toIndex === -1) {\r\n            toIndex = 0;\r\n        }\r\n        if (fromIndex === -1) {\r\n            fromIndex = 0;\r\n        }\r\n        const delta = toIndex - fromIndex;\r\n        if (delta) {\r\n            forceNextPop = true;\r\n            go(delta);\r\n        }\r\n    };\r\n    const initialLocation = getDOMLocation(getHistoryState());\r\n    let allKeys = [initialLocation.key];\r\n    let listenerCount = 0;\r\n    let isBlocked = false;\r\n    // Public interface\r\n    const createHref = (location) => {\r\n        return basename + createPath(location);\r\n    };\r\n    const push = (path, state) => {\r\n        warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' +\r\n            'argument is a location-like object that already has state; it is ignored');\r\n        const action = 'PUSH';\r\n        const location = createLocation(path, state, createKey(keyLength), history.location);\r\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n            if (!ok) {\r\n                return;\r\n            }\r\n            const href = createHref(location);\r\n            const { key, state } = location;\r\n            if (canUseHistory) {\r\n                globalHistory.pushState({ key, state }, '', href);\r\n                if (forceRefresh) {\r\n                    globalLocation.href = href;\r\n                }\r\n                else {\r\n                    const prevIndex = allKeys.indexOf(history.location.key);\r\n                    const nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\r\n                    nextKeys.push(location.key);\r\n                    allKeys = nextKeys;\r\n                    setState({ action, location });\r\n                }\r\n            }\r\n            else {\r\n                warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');\r\n                globalLocation.href = href;\r\n            }\r\n        });\r\n    };\r\n    const replace = (path, state) => {\r\n        warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' +\r\n            'argument is a location-like object that already has state; it is ignored');\r\n        const action = 'REPLACE';\r\n        const location = createLocation(path, state, createKey(keyLength), history.location);\r\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n            if (!ok) {\r\n                return;\r\n            }\r\n            const href = createHref(location);\r\n            const { key, state } = location;\r\n            if (canUseHistory) {\r\n                globalHistory.replaceState({ key, state }, '', href);\r\n                if (forceRefresh) {\r\n                    globalLocation.replace(href);\r\n                }\r\n                else {\r\n                    const prevIndex = allKeys.indexOf(history.location.key);\r\n                    if (prevIndex !== -1) {\r\n                        allKeys[prevIndex] = location.key;\r\n                    }\r\n                    setState({ action, location });\r\n                }\r\n            }\r\n            else {\r\n                warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');\r\n                globalLocation.replace(href);\r\n            }\r\n        });\r\n    };\r\n    const go = (n) => {\r\n        globalHistory.go(n);\r\n    };\r\n    const goBack = () => go(-1);\r\n    const goForward = () => go(1);\r\n    const checkDOMListeners = (delta) => {\r\n        listenerCount += delta;\r\n        if (listenerCount === 1) {\r\n            win.addEventListener(PopStateEvent, handlePopState);\r\n            if (needsHashChangeListener) {\r\n                win.addEventListener(HashChangeEvent, handleHashChange);\r\n            }\r\n        }\r\n        else if (listenerCount === 0) {\r\n            win.removeEventListener(PopStateEvent, handlePopState);\r\n            if (needsHashChangeListener) {\r\n                win.removeEventListener(HashChangeEvent, handleHashChange);\r\n            }\r\n        }\r\n    };\r\n    const block = (prompt = '') => {\r\n        const unblock = transitionManager.setPrompt(prompt);\r\n        if (!isBlocked) {\r\n            checkDOMListeners(1);\r\n            isBlocked = true;\r\n        }\r\n        return () => {\r\n            if (isBlocked) {\r\n                isBlocked = false;\r\n                checkDOMListeners(-1);\r\n            }\r\n            return unblock();\r\n        };\r\n    };\r\n    const listen = (listener) => {\r\n        const unlisten = transitionManager.appendListener(listener);\r\n        checkDOMListeners(1);\r\n        return () => {\r\n            checkDOMListeners(-1);\r\n            unlisten();\r\n        };\r\n    };\r\n    const history = {\r\n        length: globalHistory.length,\r\n        action: 'POP',\r\n        location: initialLocation,\r\n        createHref,\r\n        push,\r\n        replace,\r\n        go,\r\n        goBack,\r\n        goForward,\r\n        block,\r\n        listen,\r\n        win: win\r\n    };\r\n    return history;\r\n};\r\nexport default createBrowserHistory;\r\n","// Adapted from the https://github.com/ReactTraining/history and converted to TypeScript\r\nimport { createLocation, locationsAreEqual, createKey } from './location-utils';\r\nimport { warning } from './log';\r\nimport { addLeadingSlash, stripLeadingSlash, stripTrailingSlash, hasBasename, stripBasename, createPath } from './path-utils';\r\nimport createTransitionManager from './createTransitionManager';\r\nimport { getConfirmation, supportsGoWithoutReloadUsingHash } from './dom-utils';\r\nconst HashChangeEvent = 'hashchange';\r\nconst HashPathCoders = {\r\n    hashbang: {\r\n        encodePath: (path) => path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path),\r\n        decodePath: (path) => path.charAt(0) === '!' ? path.substr(1) : path\r\n    },\r\n    noslash: {\r\n        encodePath: stripLeadingSlash,\r\n        decodePath: addLeadingSlash\r\n    },\r\n    slash: {\r\n        encodePath: addLeadingSlash,\r\n        decodePath: addLeadingSlash\r\n    }\r\n};\r\nconst createHashHistory = (win, props = {}) => {\r\n    let forceNextPop = false;\r\n    let ignorePath = null;\r\n    let listenerCount = 0;\r\n    let isBlocked = false;\r\n    const globalLocation = win.location;\r\n    const globalHistory = win.history;\r\n    const canGoWithoutReload = supportsGoWithoutReloadUsingHash(win.navigator);\r\n    const keyLength = (props.keyLength != null) ? props.keyLength : 6;\r\n    const { getUserConfirmation = getConfirmation, hashType = 'slash' } = props;\r\n    const basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\r\n    const { encodePath, decodePath } = HashPathCoders[hashType];\r\n    const getHashPath = () => {\r\n        // We can't use window.location.hash here because it's not\r\n        // consistent across browsers - Firefox will pre-decode it!\r\n        const href = globalLocation.href;\r\n        const hashIndex = href.indexOf('#');\r\n        return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\r\n    };\r\n    const pushHashPath = (path) => (globalLocation.hash = path);\r\n    const replaceHashPath = (path) => {\r\n        const hashIndex = globalLocation.href.indexOf('#');\r\n        globalLocation.replace(globalLocation.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\r\n    };\r\n    const getDOMLocation = () => {\r\n        let path = decodePath(getHashPath());\r\n        warning((!basename || hasBasename(path, basename)), 'You are attempting to use a basename on a page whose URL path does not begin ' +\r\n            'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\r\n        if (basename) {\r\n            path = stripBasename(path, basename);\r\n        }\r\n        return createLocation(path, undefined, createKey(keyLength));\r\n    };\r\n    const transitionManager = createTransitionManager();\r\n    const setState = (nextState) => {\r\n        Object.assign(history, nextState);\r\n        history.length = globalHistory.length;\r\n        transitionManager.notifyListeners(history.location, history.action);\r\n    };\r\n    const handleHashChange = () => {\r\n        const path = getHashPath();\r\n        const encodedPath = encodePath(path);\r\n        if (path !== encodedPath) {\r\n            // Ensure we always have a properly-encoded hash.\r\n            replaceHashPath(encodedPath);\r\n        }\r\n        else {\r\n            const location = getDOMLocation();\r\n            const prevLocation = history.location;\r\n            if (!forceNextPop && locationsAreEqual(prevLocation, location)) {\r\n                return; // A hashchange doesn't always == location change.\r\n            }\r\n            if (ignorePath === createPath(location)) {\r\n                return; // Ignore this change; we already setState in push/replace.\r\n            }\r\n            ignorePath = null;\r\n            handlePop(location);\r\n        }\r\n    };\r\n    const handlePop = (location) => {\r\n        if (forceNextPop) {\r\n            forceNextPop = false;\r\n            setState();\r\n        }\r\n        else {\r\n            const action = 'POP';\r\n            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n                if (ok) {\r\n                    setState({ action, location });\r\n                }\r\n                else {\r\n                    revertPop(location);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    const revertPop = (fromLocation) => {\r\n        const toLocation = history.location;\r\n        // TODO: We could probably make this more reliable by\r\n        // keeping a list of paths we've seen in sessionStorage.\r\n        // Instead, we just default to 0 for paths we don't know.\r\n        let toIndex = allPaths.lastIndexOf(createPath(toLocation));\r\n        let fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\r\n        if (toIndex === -1) {\r\n            toIndex = 0;\r\n        }\r\n        if (fromIndex === -1) {\r\n            fromIndex = 0;\r\n        }\r\n        const delta = toIndex - fromIndex;\r\n        if (delta) {\r\n            forceNextPop = true;\r\n            go(delta);\r\n        }\r\n    };\r\n    // Ensure the hash is encoded properly before doing anything else.\r\n    const path = getHashPath();\r\n    const encodedPath = encodePath(path);\r\n    if (path !== encodedPath) {\r\n        replaceHashPath(encodedPath);\r\n    }\r\n    const initialLocation = getDOMLocation();\r\n    let allPaths = [createPath(initialLocation)];\r\n    // Public interface\r\n    const createHref = (location) => ('#' + encodePath(basename + createPath(location)));\r\n    const push = (path, state) => {\r\n        warning(state === undefined, 'Hash history cannot push state; it is ignored');\r\n        const action = 'PUSH';\r\n        const location = createLocation(path, undefined, createKey(keyLength), history.location);\r\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n            if (!ok) {\r\n                return;\r\n            }\r\n            const path = createPath(location);\r\n            const encodedPath = encodePath(basename + path);\r\n            const hashChanged = getHashPath() !== encodedPath;\r\n            if (hashChanged) {\r\n                // We cannot tell if a hashchange was caused by a PUSH, so we'd\r\n                // rather setState here and ignore the hashchange. The caveat here\r\n                // is that other hash histories in the page will consider it a POP.\r\n                ignorePath = path;\r\n                pushHashPath(encodedPath);\r\n                const prevIndex = allPaths.lastIndexOf(createPath(history.location));\r\n                const nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\r\n                nextPaths.push(path);\r\n                allPaths = nextPaths;\r\n                setState({ action, location });\r\n            }\r\n            else {\r\n                warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\r\n                setState();\r\n            }\r\n        });\r\n    };\r\n    const replace = (path, state) => {\r\n        warning(state === undefined, 'Hash history cannot replace state; it is ignored');\r\n        const action = 'REPLACE';\r\n        const location = createLocation(path, undefined, createKey(keyLength), history.location);\r\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n            if (!ok) {\r\n                return;\r\n            }\r\n            const path = createPath(location);\r\n            const encodedPath = encodePath(basename + path);\r\n            const hashChanged = getHashPath() !== encodedPath;\r\n            if (hashChanged) {\r\n                // We cannot tell if a hashchange was caused by a REPLACE, so we'd\r\n                // rather setState here and ignore the hashchange. The caveat here\r\n                // is that other hash histories in the page will consider it a POP.\r\n                ignorePath = path;\r\n                replaceHashPath(encodedPath);\r\n            }\r\n            const prevIndex = allPaths.indexOf(createPath(history.location));\r\n            if (prevIndex !== -1) {\r\n                allPaths[prevIndex] = path;\r\n            }\r\n            setState({ action, location });\r\n        });\r\n    };\r\n    const go = (n) => {\r\n        warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\r\n        globalHistory.go(n);\r\n    };\r\n    const goBack = () => go(-1);\r\n    const goForward = () => go(1);\r\n    const checkDOMListeners = (win, delta) => {\r\n        listenerCount += delta;\r\n        if (listenerCount === 1) {\r\n            win.addEventListener(HashChangeEvent, handleHashChange);\r\n        }\r\n        else if (listenerCount === 0) {\r\n            win.removeEventListener(HashChangeEvent, handleHashChange);\r\n        }\r\n    };\r\n    const block = (prompt = '') => {\r\n        const unblock = transitionManager.setPrompt(prompt);\r\n        if (!isBlocked) {\r\n            checkDOMListeners(win, 1);\r\n            isBlocked = true;\r\n        }\r\n        return () => {\r\n            if (isBlocked) {\r\n                isBlocked = false;\r\n                checkDOMListeners(win, -1);\r\n            }\r\n            return unblock();\r\n        };\r\n    };\r\n    const listen = (listener) => {\r\n        const unlisten = transitionManager.appendListener(listener);\r\n        checkDOMListeners(win, 1);\r\n        return () => {\r\n            checkDOMListeners(win, -1);\r\n            unlisten();\r\n        };\r\n    };\r\n    const history = {\r\n        length: globalHistory.length,\r\n        action: 'POP',\r\n        location: initialLocation,\r\n        createHref,\r\n        push,\r\n        replace,\r\n        go,\r\n        goBack,\r\n        goForward,\r\n        block,\r\n        listen,\r\n        win: win\r\n    };\r\n    return history;\r\n};\r\nexport default createHashHistory;\r\n","import { h } from '@stencil/core';\r\nimport createHistory from '../../utils/createBrowserHistory';\r\nimport createHashHistory from '../../utils/createHashHistory';\r\nimport ActiveRouter from '../../global/active-router';\r\nconst getLocation = (location, root) => {\r\n    // Remove the root URL if found at beginning of string\r\n    const pathname = location.pathname.indexOf(root) == 0 ?\r\n        '/' + location.pathname.slice(root.length) :\r\n        location.pathname;\r\n    return Object.assign({}, location, { pathname });\r\n};\r\nconst HISTORIES = {\r\n    'browser': createHistory,\r\n    'hash': createHashHistory\r\n};\r\n/**\r\n  * @name Router\r\n  * @module ionic\r\n  * @description\r\n */\r\nexport class Router {\r\n    constructor() {\r\n        this.root = '/';\r\n        this.historyType = 'browser';\r\n        // A suffix to append to the page title whenever\r\n        // it's updated through RouteTitle\r\n        this.titleSuffix = '';\r\n        this.routeViewsUpdated = (options = {}) => {\r\n            if (this.history && options.scrollToId && this.historyType === 'browser') {\r\n                const elm = this.history.win.document.getElementById(options.scrollToId);\r\n                if (elm) {\r\n                    return elm.scrollIntoView();\r\n                }\r\n            }\r\n            this.scrollTo(options.scrollTopOffset || this.scrollTopOffset);\r\n        };\r\n    }\r\n    componentWillLoad() {\r\n        this.history = HISTORIES[this.historyType](this.el.ownerDocument.defaultView);\r\n        this.history.listen((location) => {\r\n            location = getLocation(location, this.root);\r\n            this.location = location;\r\n        });\r\n        this.location = getLocation(this.history.location, this.root);\r\n    }\r\n    scrollTo(scrollToLocation) {\r\n        const history = this.history;\r\n        if (scrollToLocation == null || this.isServer || !history) {\r\n            return;\r\n        }\r\n        if (history.action === 'POP' && Array.isArray(history.location.scrollPosition)) {\r\n            return this.queue.write(() => {\r\n                if (history && history.location && Array.isArray(history.location.scrollPosition)) {\r\n                    history.win.scrollTo(history.location.scrollPosition[0], history.location.scrollPosition[1]);\r\n                }\r\n            });\r\n        }\r\n        // okay, the frame has passed. Go ahead and render now\r\n        return this.queue.write(() => {\r\n            history.win.scrollTo(0, scrollToLocation);\r\n        });\r\n    }\r\n    render() {\r\n        if (!this.location || !this.history) {\r\n            return;\r\n        }\r\n        const state = {\r\n            historyType: this.historyType,\r\n            location: this.location,\r\n            titleSuffix: this.titleSuffix,\r\n            root: this.root,\r\n            history: this.history,\r\n            routeViewsUpdated: this.routeViewsUpdated\r\n        };\r\n        return (h(ActiveRouter.Provider, { state: state },\r\n            h(\"slot\", null)));\r\n    }\r\n    static get is() { return \"stencil-router\"; }\r\n    static get properties() { return {\r\n        \"root\": {\r\n            \"type\": \"string\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"string\",\r\n                \"resolved\": \"string\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"root\",\r\n            \"reflect\": false,\r\n            \"defaultValue\": \"'/'\"\r\n        },\r\n        \"historyType\": {\r\n            \"type\": \"string\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"HistoryType\",\r\n                \"resolved\": \"\\\"browser\\\" | \\\"hash\\\"\",\r\n                \"references\": {\r\n                    \"HistoryType\": {\r\n                        \"location\": \"import\",\r\n                        \"path\": \"../../global/interfaces\"\r\n                    }\r\n                }\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"history-type\",\r\n            \"reflect\": false,\r\n            \"defaultValue\": \"'browser'\"\r\n        },\r\n        \"titleSuffix\": {\r\n            \"type\": \"string\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"string\",\r\n                \"resolved\": \"string\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": false,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"title-suffix\",\r\n            \"reflect\": false,\r\n            \"defaultValue\": \"''\"\r\n        },\r\n        \"scrollTopOffset\": {\r\n            \"type\": \"number\",\r\n            \"mutable\": false,\r\n            \"complexType\": {\r\n                \"original\": \"number\",\r\n                \"resolved\": \"number | undefined\",\r\n                \"references\": {}\r\n            },\r\n            \"required\": false,\r\n            \"optional\": true,\r\n            \"docs\": {\r\n                \"tags\": [],\r\n                \"text\": \"\"\r\n            },\r\n            \"attribute\": \"scroll-top-offset\",\r\n            \"reflect\": false\r\n        }\r\n    }; }\r\n    static get contextProps() { return [{\r\n            \"name\": \"isServer\",\r\n            \"context\": \"isServer\"\r\n        }, {\r\n            \"name\": \"queue\",\r\n            \"context\": \"queue\"\r\n        }]; }\r\n    static get states() { return {\r\n        \"location\": {},\r\n        \"history\": {}\r\n    }; }\r\n    static get elementRef() { return \"el\"; }\r\n}\r\n"],"mappings":"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"}