{"version":3,"names":["DEFAULT_DELIMITER","DEFAULT_DELIMITERS","PATH_REGEXP","RegExp","join","parse","str","options","tokens","key","index","path","defaultDelimiter","delimiter","delimiters","pathEscaped","res","exec","m","escaped","offset","slice","length","prev","next","name","capture","group","modifier","k","indexOf","push","partial","undefined","repeat","optional","pattern","prefix","escapeGroup","escapeString","substr","replace","flags","sensitive","regexpToRegexp","keys","groups","source","match","i","arrayToRegexp","parts","pathToRegexp","stringToRegexp","tokensToRegExp","strict","end","endsWith","concat","map","route","isEndDelimited","token","Array","isArray","hasBasename","test","stripBasename","stripTrailingSlash","charAt","addLeadingSlash","stripLeadingSlash","parsePath","pathname","search","hash","hashIndex","searchIndex","query","createPath","location","parseQueryString","split","reduce","params","param","value","decodeURIComponent","isAbsolute","createKey","keyLength","Math","random","toString","spliceOne","list","n","pop","resolvePathname","to","from","fromParts","hasTrailingSlash","up","toParts","isToAbs","isFromAbs","mustEndAbs","last","part","unshift","result","valueEqual","a","b","every","item","aType","bType","aValue","valueOf","bValue","aKeys","Object","bKeys","locationsAreEqual","state","createLocation","currentLocation","assign","decodeURI","e","URIError","cacheCount","patternCache","cacheLimit","compilePath","cacheKey","cache","cachePattern","JSON","stringify","re","compiledPattern","matchPath","exact","url","values","isExact","memo","matchesAreEqual","getConfirmation","win","message","callback","confirm","isModifiedEvent","ev","metaKey","altKey","ctrlKey","shiftKey","supportsHistory","ua","navigator","userAgent","history","supportsPopStateOnHashChange","nav","supportsGoWithoutReloadUsingHash","isExtraneousPopstateEvent","event","storageAvailable","type","storage","x","setItem","removeItem","DOMException","code"],"sources":["../../../node_modules/@stencil/router/dist/collection/utils/path-to-regex.js","../../../node_modules/@stencil/router/dist/collection/utils/path-utils.js","../../../node_modules/@stencil/router/dist/collection/utils/location-utils.js","../../../node_modules/@stencil/router/dist/collection/utils/match-path.js","../../../node_modules/@stencil/router/dist/collection/utils/dom-utils.js"],"sourcesContent":["/**\r\n * TS adaption of https://github.com/pillarjs/path-to-regexp/blob/master/index.js\r\n */\r\n/**\r\n * Default configs.\r\n */\r\nconst DEFAULT_DELIMITER = '/';\r\nconst DEFAULT_DELIMITERS = './';\r\n/**\r\n * The main path matching regexp utility.\r\n */\r\nconst PATH_REGEXP = new RegExp([\r\n    // Match escaped characters that would otherwise appear in future matches.\r\n    // This allows the user to escape special characters that won't transform.\r\n    '(\\\\\\\\.)',\r\n    // Match Express-style parameters and un-named parameters with a prefix\r\n    // and optional suffixes. Matches appear as:\r\n    //\r\n    // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\"]\r\n    // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined]\r\n    '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\r\n].join('|'), 'g');\r\n/**\r\n * Parse a string for the raw tokens.\r\n */\r\nexport const parse = (str, options) => {\r\n    var tokens = [];\r\n    var key = 0;\r\n    var index = 0;\r\n    var path = '';\r\n    var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER;\r\n    var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS;\r\n    var pathEscaped = false;\r\n    var res;\r\n    while ((res = PATH_REGEXP.exec(str)) !== null) {\r\n        var m = res[0];\r\n        var escaped = res[1];\r\n        var offset = res.index;\r\n        path += str.slice(index, offset);\r\n        index = offset + m.length;\r\n        // Ignore already escaped sequences.\r\n        if (escaped) {\r\n            path += escaped[1];\r\n            pathEscaped = true;\r\n            continue;\r\n        }\r\n        var prev = '';\r\n        var next = str[index];\r\n        var name = res[2];\r\n        var capture = res[3];\r\n        var group = res[4];\r\n        var modifier = res[5];\r\n        if (!pathEscaped && path.length) {\r\n            var k = path.length - 1;\r\n            if (delimiters.indexOf(path[k]) > -1) {\r\n                prev = path[k];\r\n                path = path.slice(0, k);\r\n            }\r\n        }\r\n        // Push the current path onto the tokens.\r\n        if (path) {\r\n            tokens.push(path);\r\n            path = '';\r\n            pathEscaped = false;\r\n        }\r\n        var partial = prev !== '' && next !== undefined && next !== prev;\r\n        var repeat = modifier === '+' || modifier === '*';\r\n        var optional = modifier === '?' || modifier === '*';\r\n        var delimiter = prev || defaultDelimiter;\r\n        var pattern = capture || group;\r\n        tokens.push({\r\n            name: name || key++,\r\n            prefix: prev,\r\n            delimiter: delimiter,\r\n            optional: optional,\r\n            repeat: repeat,\r\n            partial: partial,\r\n            pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'\r\n        });\r\n    }\r\n    // Push any remaining characters.\r\n    if (path || index < str.length) {\r\n        tokens.push(path + str.substr(index));\r\n    }\r\n    return tokens;\r\n};\r\n/**\r\n * Compile a string to a template function for the path.\r\n */\r\nexport const compile = (str, options) => {\r\n    return tokensToFunction(parse(str, options));\r\n};\r\n/**\r\n * Expose a method for transforming tokens into the path function.\r\n */\r\nexport const tokensToFunction = (tokens) => {\r\n    // Compile all the tokens into regexps.\r\n    var matches = new Array(tokens.length);\r\n    // Compile all the patterns before compilation.\r\n    for (var i = 0; i < tokens.length; i++) {\r\n        var token = tokens[i];\r\n        if (typeof token === 'object') {\r\n            matches[i] = new RegExp('^(?:' + token.pattern + ')$');\r\n        }\r\n    }\r\n    return (data, options) => {\r\n        var path = '';\r\n        var encode = (options && options.encode) || encodeURIComponent;\r\n        for (var i = 0; i < tokens.length; i++) {\r\n            var token = tokens[i];\r\n            if (typeof token === 'string') {\r\n                path += token;\r\n                continue;\r\n            }\r\n            var value = data ? data[token.name] : undefined;\r\n            var segment;\r\n            if (Array.isArray(value)) {\r\n                if (!token.repeat) {\r\n                    throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array');\r\n                }\r\n                if (value.length === 0) {\r\n                    if (token.optional)\r\n                        continue;\r\n                    throw new TypeError('Expected \"' + token.name + '\" to not be empty');\r\n                }\r\n                for (var j = 0; j < value.length; j++) {\r\n                    segment = encode(value[j]);\r\n                    if (!matches[i].test(segment)) {\r\n                        throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\"');\r\n                    }\r\n                    path += (j === 0 ? token.prefix : token.delimiter) + segment;\r\n                }\r\n                continue;\r\n            }\r\n            if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\r\n                segment = encode(String(value));\r\n                if (!matches[i].test(segment)) {\r\n                    throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"');\r\n                }\r\n                path += token.prefix + segment;\r\n                continue;\r\n            }\r\n            if (token.optional) {\r\n                // Prepend partial segment prefixes.\r\n                if (token.partial)\r\n                    path += token.prefix;\r\n                continue;\r\n            }\r\n            throw new TypeError('Expected \"' + token.name + '\" to be ' + (token.repeat ? 'an array' : 'a string'));\r\n        }\r\n        return path;\r\n    };\r\n};\r\n/**\r\n * Escape a regular expression string.\r\n */\r\nconst escapeString = (str) => {\r\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1');\r\n};\r\n/**\r\n * Escape the capturing group by escaping special characters and meaning.\r\n */\r\nconst escapeGroup = (group) => {\r\n    return group.replace(/([=!:$/()])/g, '\\\\$1');\r\n};\r\n/**\r\n * Get the flags for a regexp from the options.\r\n */\r\nconst flags = (options) => {\r\n    return options && options.sensitive ? '' : 'i';\r\n};\r\n/**\r\n * Pull out keys from a regexp.\r\n */\r\nconst regexpToRegexp = (path, keys) => {\r\n    if (!keys)\r\n        return path;\r\n    // Use a negative lookahead to match only capturing groups.\r\n    var groups = path.source.match(/\\((?!\\?)/g);\r\n    if (groups) {\r\n        for (var i = 0; i < groups.length; i++) {\r\n            keys.push({\r\n                name: i,\r\n                prefix: null,\r\n                delimiter: null,\r\n                optional: false,\r\n                repeat: false,\r\n                partial: false,\r\n                pattern: null\r\n            });\r\n        }\r\n    }\r\n    return path;\r\n};\r\n/**\r\n * Transform an array into a regexp.\r\n */\r\nconst arrayToRegexp = (path, keys, options) => {\r\n    var parts = [];\r\n    for (var i = 0; i < path.length; i++) {\r\n        parts.push(pathToRegexp(path[i], keys, options).source);\r\n    }\r\n    return new RegExp('(?:' + parts.join('|') + ')', flags(options));\r\n};\r\n/**\r\n * Create a path regexp from string input.\r\n */\r\nconst stringToRegexp = (path, keys, options) => {\r\n    return tokensToRegExp(parse(path, options), keys, options);\r\n};\r\n/**\r\n * Expose a function for taking tokens and returning a RegExp.\r\n */\r\nexport const tokensToRegExp = (tokens, keys, options) => {\r\n    options = options || {};\r\n    var strict = options.strict;\r\n    var end = options.end !== false;\r\n    var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER);\r\n    var delimiters = options.delimiters || DEFAULT_DELIMITERS;\r\n    var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|');\r\n    var route = '';\r\n    var isEndDelimited = false;\r\n    // Iterate over the tokens and create our regexp string.\r\n    for (var i = 0; i < tokens.length; i++) {\r\n        var token = tokens[i];\r\n        if (typeof token === 'string') {\r\n            route += escapeString(token);\r\n            isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1;\r\n        }\r\n        else {\r\n            var prefix = escapeString(token.prefix || '');\r\n            var capture = token.repeat\r\n                ? '(?:' + token.pattern + ')(?:' + prefix + '(?:' + token.pattern + '))*'\r\n                : token.pattern;\r\n            if (keys)\r\n                keys.push(token);\r\n            if (token.optional) {\r\n                if (token.partial) {\r\n                    route += prefix + '(' + capture + ')?';\r\n                }\r\n                else {\r\n                    route += '(?:' + prefix + '(' + capture + '))?';\r\n                }\r\n            }\r\n            else {\r\n                route += prefix + '(' + capture + ')';\r\n            }\r\n        }\r\n    }\r\n    if (end) {\r\n        if (!strict)\r\n            route += '(?:' + delimiter + ')?';\r\n        route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';\r\n    }\r\n    else {\r\n        if (!strict)\r\n            route += '(?:' + delimiter + '(?=' + endsWith + '))?';\r\n        if (!isEndDelimited)\r\n            route += '(?=' + delimiter + '|' + endsWith + ')';\r\n    }\r\n    return new RegExp('^' + route, flags(options));\r\n};\r\n/**\r\n * Normalize the given path string, returning a regular expression.\r\n *\r\n * An empty array can be passed in for the keys, which will hold the\r\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\r\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\r\n */\r\nexport const pathToRegexp = (path, keys, options) => {\r\n    if (path instanceof RegExp) {\r\n        return regexpToRegexp(path, keys);\r\n    }\r\n    if (Array.isArray(path)) {\r\n        return arrayToRegexp(path, keys, options);\r\n    }\r\n    return stringToRegexp(path, keys, options);\r\n};\r\n","export const hasBasename = (path, prefix) => {\r\n    return (new RegExp('^' + prefix + '(\\\\/|\\\\?|#|$)', 'i')).test(path);\r\n};\r\nexport const stripBasename = (path, prefix) => {\r\n    return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\r\n};\r\nexport const stripTrailingSlash = (path) => {\r\n    return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\r\n};\r\nexport const addLeadingSlash = (path) => {\r\n    return path.charAt(0) === '/' ? path : '/' + path;\r\n};\r\nexport const stripLeadingSlash = (path) => {\r\n    return path.charAt(0) === '/' ? path.substr(1) : path;\r\n};\r\nexport const stripPrefix = (path, prefix) => {\r\n    return path.indexOf(prefix) === 0 ? path.substr(prefix.length) : path;\r\n};\r\nexport const parsePath = (path) => {\r\n    let pathname = path || '/';\r\n    let search = '';\r\n    let hash = '';\r\n    const hashIndex = pathname.indexOf('#');\r\n    if (hashIndex !== -1) {\r\n        hash = pathname.substr(hashIndex);\r\n        pathname = pathname.substr(0, hashIndex);\r\n    }\r\n    const searchIndex = pathname.indexOf('?');\r\n    if (searchIndex !== -1) {\r\n        search = pathname.substr(searchIndex);\r\n        pathname = pathname.substr(0, searchIndex);\r\n    }\r\n    return {\r\n        pathname,\r\n        search: search === '?' ? '' : search,\r\n        hash: hash === '#' ? '' : hash,\r\n        query: {},\r\n        key: ''\r\n    };\r\n};\r\nexport const createPath = (location) => {\r\n    const { pathname, search, hash } = location;\r\n    let path = pathname || '/';\r\n    if (search && search !== '?') {\r\n        path += (search.charAt(0) === '?' ? search : `?${search}`);\r\n    }\r\n    if (hash && hash !== '#') {\r\n        path += (hash.charAt(0) === '#' ? hash : `#${hash}`);\r\n    }\r\n    return path;\r\n};\r\nexport const parseQueryString = (query) => {\r\n    if (!query) {\r\n        return {};\r\n    }\r\n    return (/^[?#]/.test(query) ? query.slice(1) : query)\r\n        .split('&')\r\n        .reduce((params, param) => {\r\n        let [key, value] = param.split('=');\r\n        params[key] = value ? decodeURIComponent(value.replace(/\\+/g, ' ')) : '';\r\n        return params;\r\n    }, {});\r\n};\r\n","import { parsePath, parseQueryString } from './path-utils';\r\nconst isAbsolute = (pathname) => {\r\n    return pathname.charAt(0) === '/';\r\n};\r\nexport const createKey = (keyLength) => {\r\n    return Math.random().toString(36).substr(2, keyLength);\r\n};\r\n// About 1.5x faster than the two-arg version of Array#splice()\r\nconst spliceOne = (list, index) => {\r\n    for (let i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\r\n        list[i] = list[k];\r\n    }\r\n    list.pop();\r\n};\r\n// This implementation is based heavily on node's url.parse\r\nexport const resolvePathname = (to, from = '') => {\r\n    let fromParts = from && from.split('/') || [];\r\n    let hasTrailingSlash;\r\n    let up = 0;\r\n    const toParts = to && to.split('/') || [];\r\n    const isToAbs = to && isAbsolute(to);\r\n    const isFromAbs = from && isAbsolute(from);\r\n    const mustEndAbs = isToAbs || isFromAbs;\r\n    if (to && isAbsolute(to)) {\r\n        // to is absolute\r\n        fromParts = toParts;\r\n    }\r\n    else if (toParts.length) {\r\n        // to is relative, drop the filename\r\n        fromParts.pop();\r\n        fromParts = fromParts.concat(toParts);\r\n    }\r\n    if (!fromParts.length) {\r\n        return '/';\r\n    }\r\n    if (fromParts.length) {\r\n        const last = fromParts[fromParts.length - 1];\r\n        hasTrailingSlash = (last === '.' || last === '..' || last === '');\r\n    }\r\n    else {\r\n        hasTrailingSlash = false;\r\n    }\r\n    for (let i = fromParts.length; i >= 0; i--) {\r\n        const part = fromParts[i];\r\n        if (part === '.') {\r\n            spliceOne(fromParts, i);\r\n        }\r\n        else if (part === '..') {\r\n            spliceOne(fromParts, i);\r\n            up++;\r\n        }\r\n        else if (up) {\r\n            spliceOne(fromParts, i);\r\n            up--;\r\n        }\r\n    }\r\n    if (!mustEndAbs) {\r\n        for (; up--; up) {\r\n            fromParts.unshift('..');\r\n        }\r\n    }\r\n    if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) {\r\n        fromParts.unshift('');\r\n    }\r\n    let result = fromParts.join('/');\r\n    if (hasTrailingSlash && result.substr(-1) !== '/') {\r\n        result += '/';\r\n    }\r\n    return result;\r\n};\r\nexport const valueEqual = (a, b) => {\r\n    if (a === b) {\r\n        return true;\r\n    }\r\n    if (a == null || b == null) {\r\n        return false;\r\n    }\r\n    if (Array.isArray(a)) {\r\n        return Array.isArray(b) && a.length === b.length && a.every((item, index) => {\r\n            return valueEqual(item, b[index]);\r\n        });\r\n    }\r\n    const aType = typeof a;\r\n    const bType = typeof b;\r\n    if (aType !== bType) {\r\n        return false;\r\n    }\r\n    if (aType === 'object') {\r\n        const aValue = a.valueOf();\r\n        const bValue = b.valueOf();\r\n        if (aValue !== a || bValue !== b) {\r\n            return valueEqual(aValue, bValue);\r\n        }\r\n        const aKeys = Object.keys(a);\r\n        const bKeys = Object.keys(b);\r\n        if (aKeys.length !== bKeys.length) {\r\n            return false;\r\n        }\r\n        return aKeys.every((key) => {\r\n            return valueEqual(a[key], b[key]);\r\n        });\r\n    }\r\n    return false;\r\n};\r\nexport const locationsAreEqual = (a, b) => {\r\n    return a.pathname === b.pathname &&\r\n        a.search === b.search &&\r\n        a.hash === b.hash &&\r\n        a.key === b.key &&\r\n        valueEqual(a.state, b.state);\r\n};\r\nexport const createLocation = (path, state, key, currentLocation) => {\r\n    let location;\r\n    if (typeof path === 'string') {\r\n        // Two-arg form: push(path, state)\r\n        location = parsePath(path);\r\n        if (state !== undefined) {\r\n            location.state = state;\r\n        }\r\n    }\r\n    else {\r\n        // One-arg form: push(location)\r\n        location = Object.assign({ pathname: '' }, path);\r\n        if (location.search && location.search.charAt(0) !== '?') {\r\n            location.search = '?' + location.search;\r\n        }\r\n        if (location.hash && location.hash.charAt(0) !== '#') {\r\n            location.hash = '#' + location.hash;\r\n        }\r\n        if (state !== undefined && location.state === undefined) {\r\n            location.state = state;\r\n        }\r\n    }\r\n    try {\r\n        location.pathname = decodeURI(location.pathname);\r\n    }\r\n    catch (e) {\r\n        if (e instanceof URIError) {\r\n            throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' +\r\n                'This is likely caused by an invalid percent-encoding.');\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n    location.key = key;\r\n    if (currentLocation) {\r\n        // Resolve incomplete/relative pathname relative to current location.\r\n        if (!location.pathname) {\r\n            location.pathname = currentLocation.pathname;\r\n        }\r\n        else if (location.pathname.charAt(0) !== '/') {\r\n            location.pathname = resolvePathname(location.pathname, currentLocation.pathname);\r\n        }\r\n    }\r\n    else {\r\n        // When there is no prior location and pathname is empty, set it to /\r\n        if (!location.pathname) {\r\n            location.pathname = '/';\r\n        }\r\n    }\r\n    location.query = parseQueryString(location.search || '');\r\n    return location;\r\n};\r\n","import { pathToRegexp } from './path-to-regex';\r\nimport { valueEqual } from './location-utils';\r\nlet cacheCount = 0;\r\nconst patternCache = {};\r\nconst cacheLimit = 10000;\r\n// Memoized function for creating the path match regex\r\nconst compilePath = (pattern, options) => {\r\n    const cacheKey = `${options.end}${options.strict}`;\r\n    const cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\r\n    const cachePattern = JSON.stringify(pattern);\r\n    if (cache[cachePattern]) {\r\n        return cache[cachePattern];\r\n    }\r\n    const keys = [];\r\n    const re = pathToRegexp(pattern, keys, options);\r\n    const compiledPattern = { re, keys };\r\n    if (cacheCount < cacheLimit) {\r\n        cache[cachePattern] = compiledPattern;\r\n        cacheCount += 1;\r\n    }\r\n    return compiledPattern;\r\n};\r\n/**\r\n * Public API for matching a URL pathname to a path pattern.\r\n */\r\nexport const matchPath = (pathname, options = {}) => {\r\n    if (typeof options === 'string') {\r\n        options = { path: options };\r\n    }\r\n    const { path = '/', exact = false, strict = false } = options;\r\n    const { re, keys } = compilePath(path, { end: exact, strict });\r\n    const match = re.exec(pathname);\r\n    if (!match) {\r\n        return null;\r\n    }\r\n    const [url, ...values] = match;\r\n    const isExact = pathname === url;\r\n    if (exact && !isExact) {\r\n        return null;\r\n    }\r\n    return {\r\n        path,\r\n        url: path === '/' && url === '' ? '/' : url,\r\n        isExact,\r\n        params: keys.reduce((memo, key, index) => {\r\n            memo[key.name] = values[index];\r\n            return memo;\r\n        }, {})\r\n    };\r\n};\r\nexport const matchesAreEqual = (a, b) => {\r\n    if (a == null && b == null) {\r\n        return true;\r\n    }\r\n    if (b == null) {\r\n        return false;\r\n    }\r\n    return a && b &&\r\n        a.path === b.path &&\r\n        a.url === b.url &&\r\n        valueEqual(a.params, b.params);\r\n};\r\n","export const getConfirmation = (win, message, callback) => (callback(win.confirm(message)));\r\nexport const isModifiedEvent = (ev) => (ev.metaKey || ev.altKey || ev.ctrlKey || ev.shiftKey);\r\n/**\r\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\r\n *\r\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\r\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\r\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\r\n */\r\nexport const supportsHistory = (win) => {\r\n    const ua = win.navigator.userAgent;\r\n    if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\r\n        ua.indexOf('Mobile Safari') !== -1 &&\r\n        ua.indexOf('Chrome') === -1 &&\r\n        ua.indexOf('Windows Phone') === -1) {\r\n        return false;\r\n    }\r\n    return win.history && 'pushState' in win.history;\r\n};\r\n/**\r\n * Returns true if browser fires popstate on hash change.\r\n * IE10 and IE11 do not.\r\n */\r\nexport const supportsPopStateOnHashChange = (nav) => (nav.userAgent.indexOf('Trident') === -1);\r\n/**\r\n * Returns false if using go(n) with hash history causes a full page reload.\r\n */\r\nexport const supportsGoWithoutReloadUsingHash = (nav) => (nav.userAgent.indexOf('Firefox') === -1);\r\nexport const isExtraneousPopstateEvent = (nav, event) => (event.state === undefined &&\r\n    nav.userAgent.indexOf('CriOS') === -1);\r\nexport const storageAvailable = (win, type) => {\r\n    const storage = win[type];\r\n    const x = '__storage_test__';\r\n    try {\r\n        storage.setItem(x, x);\r\n        storage.removeItem(x);\r\n        return true;\r\n    }\r\n    catch (e) {\r\n        return e instanceof DOMException && (\r\n        // everything except Firefox\r\n        e.code === 22 ||\r\n            // Firefox\r\n            e.code === 1014 ||\r\n            // test name field too, because code might not be present\r\n            // everything except Firefox\r\n            e.name === 'QuotaExceededError' ||\r\n            // Firefox\r\n            e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\r\n            // acknowledge QuotaExceededError only if there's something already stored\r\n            storage.length !== 0;\r\n    }\r\n};\r\n"],"mappings":"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"}